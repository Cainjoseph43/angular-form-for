<div class="container">
  <h1>Validation Types</h1>

  <p>
    formFor supports the following validation rules:
  </p>

  <dl>
    <dt>required <code>Boolean</code></dt>
    <dd>A truthy value must be specified for this field.</dd>
    <dt>increment <code>int</code></dt>
    <dd>Numeric value must be in increments of this.</dd>
    <dt>minlength <code>int</code></dt>
    <dd>Field must contain at least this many characters.</dd>
    <dt>minimum <code>int</code></dt>
    <dd>Numeric value must be no smaller than this.</dd>
    <dt>maxlength <code>int</code></dt>
    <dd>Field must contain no more than this many characters.</dd>
    <dt>maximum <code>int</code></dt>
    <dd>Numeric value must be no larger than this.</dd>
    <dt>pattern <code>RegExp</code></dt>
    <dd>Field must match this regular expression.</dd>
    <dt>type <code>String</code></dt>
    <dd>Enumeration for common validation types. Supported types include <em>integer</em>, <em>number</em>, <em>positive</em>, <em>negative</em>, and <em>email</em>. You can also stack types (ex. <em>positive integer</em>, <em>negative number</em>).</dd>
    <dt>custom <code>Function</code></dt>
    <dd>Field must be approved by this custom validation function (see below for more details).</dd>
  </dl>

  <p class="alert alert-info">
    Continue reading for validation syntax examples or
    refer to the <a href="#/demo/manual-form-markup">form markup demo</a> for an example of validations.
  </p>

  <h2>Collection Validations</h2>

  <p>
    formFor also supports the following validation rules as they apply to collections:
  </p>

  <dl>
    <dt>min <code>int</code></dt>
    <dd>Collection must contain at least this many items.</dd>
    <dt>max <code>int</code></dt>
    <dd>Collection may contain no more than this many items.</dd>
  </dl>

  <p class="alert alert-info">
    Continue reading for validation syntax examples or
    refer to the <a href="#/demo/collections-form">collections form demo</a> for an example of validations.
  </p>

  <h2>Defining validations</h2>

  <p>
    Validation rules can be passed in as an array or defined on a service accessible to the $injector.
    If defined on a service, rules should be stored in a validationRules attribute.
    This attribute should be a hash with field names as keys that point to validation criteria.
  </p>

  <p>
    If we configure formFor like this:
  </p>

  <prism parser="markup" source="app/samples/defining-validations.html"></prism>

  <p>
    Then our UserSignUp service might look like this:
  </p>

  <prism parser="javascript" source="app/samples/defining-validations.js"></prism>

  <p>
    We could also configure formFor to validate based on a set of rules attached to the $scope like this:
  </p>

  <div ng-init="user = {}"></div>
  <prism><form form-for="user" validation-rules="rules"></form></prism>

  <h2>Validating Nested Fields <small>(dot notation)</small></h2>

  <p>
    formFor also supports nested fields. Here's a short example of the syntax:
  </p>

  <prism parser="markup" source="app/samples/validating-nested-fields.html"></prism>

  <p>
    The controller for the above form snippet might look something like this:
  </p>

  <prism parser="javascript" source="app/samples/validating-nested-fields.js"></prism>

  <h2>Validating Collections</h2>

  <div ng-include="'app/views/partials/parse-warning.html'"></div>

  <p>
    formFor supports collections (one to many relationships). Here's a short example of the syntax:
  </p>

  <prism parser="markup" source="app/samples/validating-collections.html"></prism>

  <p>
    The controller for the above form snippet might look something like this:
  </p>

  <prism parser="javascript" source="app/samples/validating-collections.js"></prism>

  <p>
    You can see a demo of the collections feature <a ui-sref="app.collections">here</a>.
  </p>

  <h2>Custom validations</h2>

  <p>
  Custom validation functions enable you to extend formFor's built in validations. This function will be passed 2 parameters: the field's current form-value and the full form-data object. It should then return either a promise to be resolved/rejected based on the validation results, or a truthy/falsy value indicating whether the specified value is valid.
  </p>

  <p>
  For example we might modify the above validation service to check if an email address was already reserved. To do that we could define a custom validation rule on the email field:
  </p>

  <prism parser="javascript" source="app/samples/custom-validation-email.js"></prism>

  <p>We could also implement a custom validation function to ensure that two password fields match:</p>

  <prism parser="javascript" source="app/samples/custom-validation-password.js"></prism>

  <h2>Custom error messages</h2>
  <p>
  Each type of validation has a built-in error message. For example if a required field is falsy formFor will display "Required field". You can override built-in error messages though by passing a hash to the validation rule. This hash must define 2 keys: rule and message.
  </p>
  <p>
  To display a custom validation error for an invalid email address in our above example we might use the following:
  </p>
  <prism parser="javascript" source="app/samples/custom-error-message-pattern.js"></prism>

  <p>
  This type of error message override can be used for each of the supported validation types except the custom validation function. This type of validation should specify its error message by rejecting the promise like so:
  </p>

  <prism parser="javascript" source="app/samples/custom-error-message-custom.js"></prism>

  <ul class="pager">
    <li class="previous"><a ui-sref="app.inputTypes"><i class="fa fa-arrow-left"></i> Input Types</a></li>
    <li class="next"><a ui-sref="app.templateOverrides">Template Overrides <i class="fa fa-arrow-right"></i></a></li>
  </ul>
</div>
